<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>音の遅延シミュレーション</title>
    <style>
        body { font-family: sans-serif; padding: 20px; text-align: center; }
        video {
            width: 100%;
            max-width: 640px;
            height: auto;
            border: 1px solid #ccc;
            background-color: #000;
        }
        .controls {
            margin-top: 20px;
            display: none;
            max-width: 640px;
            margin-left: auto;
            margin-right: auto;
            text-align: left;
        }
        label { display: block; margin-top: 15px; }
        input[type="range"] { width: 100%; }
        button {
            font-size: 1.1em;
            padding: 10px 15px;
            cursor: pointer;
            margin-top: 10px;
        }
        .distance-input-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="number"] {
            width: 100px;
            font-size: 1em;
            padding: 5px;
        }
        .toggle-container {
            margin-top: 20px;
        }
        #distanceLimitMessage {
            font-size: 0.9em;
            color: #666;
            margin-top: 5px;
        }
        .camera-controls {
            margin-top: 10px;
        }
    </style>
</head>
<body>

    <h1>音の伝わり方 シミュレーション</h1>
    <div id="status"><p>下のボタンを押してシミュレーションを開始してください。</p></div>

    <button id="startButton">シミュレーション開始</button>

    <video id="video" autoplay playsinline muted></video>

    <div class="camera-controls">
        <button id="cameraToggleButton" style="display: none;">カメラOFF</button>
        <button id="cameraSwitchButton" style="display: none;">カメラ切り替え</button>
    </div>

    <div id="controls" class="controls">
        <label for="speed">音の速さ (m/s):</label>
        <select id="speed">
            <option value="340">空気中 (340 m/s)</option>
            <option value="1500">水中 (1500 m/s)</option>
            <option value="5000">鉄の中 (5000 m/s)</option>
        </select>

        <label for="distance">音源からの距離:</label>
        <div class="distance-input-container">
            <input type="number" id="distanceInput" min="0" value="0">
            <select id="unitSelector">
                <option value="m">m</option>
                <option value="km">km</option>
            </select>
        </div>
        <input type="range" id="distanceSlider" min="0" value="0">
        <p id="distanceLimitMessage"></p>

        <label for="volumeSlider">音量:</label>
        <input type="range" id="volumeSlider" min="0" max="1" value="1" step="0.01">

        <div class="toggle-container">
            <label for="toggleDelay" style="display: inline-block; margin-top: 0;">
                <input type="checkbox" id="toggleDelay" checked>
                遅延時間を表示する
            </label>
        </div>

        <p id="delayDisplayContainer">計算された遅延時間: <b id="delayValue">0.00</b> 秒</p>
    </div>

<script>
    // === 1. HTML要素の取得 ===
    const startButton = document.getElementById('startButton');
    const cameraToggleButton = document.getElementById('cameraToggleButton');
    const cameraSwitchButton = document.getElementById('cameraSwitchButton');
    const videoElement = document.getElementById('video');
    const statusElement = document.getElementById('status');
    const controlsElement = document.getElementById('controls');
    const speedSelector = document.getElementById('speed');
    const delayValue = document.getElementById('delayValue');
    const distanceInput = document.getElementById('distanceInput');
    const unitSelector = document.getElementById('unitSelector');
    const distanceSlider = document.getElementById('distanceSlider');
    const volumeSlider = document.getElementById('volumeSlider');
    const toggleDelay = document.getElementById('toggleDelay');
    const delayDisplayContainer = document.getElementById('delayDisplayContainer');
    const distanceLimitMessage = document.getElementById('distanceLimitMessage');

    // === 2. Web Audio API と定数の準備 ===
    const audioContext = new AudioContext();
    const MAX_DELAY_SECONDS = 180.0;
    let delayNode = audioContext.createDelay(MAX_DELAY_SECONDS);
    const gainNode = audioContext.createGain();

    // === 3. グローバル変数の定義 ===
    let currentStream;
    let videoDevices = [];
    let currentDeviceIndex = 0;
    let audioSourceNode = null;
    let isCameraOn = false;

    // === 4. 関数定義 ===

    // 音声バッファをリセットする関数
    function resetAudioBuffer() {
        const currentGain = gainNode.gain.value;
        gainNode.gain.setValueAtTime(currentGain, audioContext.currentTime);
        gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.05);
        gainNode.gain.linearRampToValueAtTime(currentGain, audioContext.currentTime + 0.1);

        if (audioSourceNode) {
            audioSourceNode.disconnect();
            delayNode.disconnect(); // 古いdelayNodeの接続も解除
            delayNode = audioContext.createDelay(MAX_DELAY_SECONDS);
            audioSourceNode.connect(delayNode);
            delayNode.connect(gainNode);
        }
    }

    // カメラを起動/再起動する関数
    async function startCamera(deviceId) {
        if (currentStream) {
            currentStream.getTracks().forEach(track => track.stop());
        }
        const constraints = { audio: true, video: { deviceId: deviceId ? { exact: deviceId } : undefined } };
        
        try {
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            currentStream = stream;
            videoElement.srcObject = stream;
            isCameraOn = true;
            cameraToggleButton.textContent = 'カメラOFF';

            if (audioSourceNode) { audioSourceNode.disconnect(); }
            audioSourceNode = audioContext.createMediaStreamSource(stream);
            audioSourceNode.connect(delayNode);

            if (videoDevices.length === 0) {
                const devices = await navigator.mediaDevices.enumerateDevices();
                videoDevices = devices.filter(device => device.kind === 'videoinput');
                if (videoDevices.length > 1) {
                    cameraSwitchButton.style.display = 'inline-block';
                }
            }
            cameraToggleButton.style.display = 'inline-block';
        } catch (error) {
            console.error("カメラの起動に失敗:", error);
            statusElement.innerHTML = "<p>エラー: カメラにアクセスできませんでした。ブラウザの設定で許可を確認してください。</p>";
        }
    }

    // カメラのON/OFFを切り替える関数
    function toggleCamera() {
        if (!currentStream) return;
        const videoTrack = currentStream.getVideoTracks()[0];
        if (!videoTrack) return;

        if (isCameraOn) {
            videoTrack.stop();
            videoElement.srcObject = null;
            cameraToggleButton.textContent = 'カメラON';
            isCameraOn = false;
        } else {
            startCamera(videoDevices[currentDeviceIndex]?.deviceId);
        }
    }

    // 遅延時間を計算し適用する関数
    function updateDelay() {
        const speed = parseFloat(speedSelector.value);
        const distanceValue = parseFloat(distanceInput.value) || 0;
        const unit = unitSelector.value;
        const distanceMeters = (unit === 'km') ? distanceValue * 1000 : distanceValue;

        if (speed > 0) {
            const realDelayTime = distanceMeters / speed;
            const playableDelayTime = Math.min(realDelayTime, MAX_DELAY_SECONDS);
            delayNode.delayTime.value = playableDelayTime;
            delayValue.textContent = realDelayTime.toFixed(2);
        }
    }

    // 距離設定UIを更新する関数
    function updateDistanceControls() {
        const speed = parseFloat(speedSelector.value);
        const unit = unitSelector.value;
        const maxDistanceMeters = speed * MAX_DELAY_SECONDS;
        const maxDistanceInUnit = (unit === 'km') ? maxDistanceMeters / 1000 : maxDistanceMeters;

        distanceSlider.step = (unit === 'km') ? 0.1 : 10;
        distanceInput.max = maxDistanceInUnit;
        distanceSlider.max = maxDistanceInUnit;
        distanceLimitMessage.textContent = `(設定可能な最大距離: ${maxDistanceInUnit.toFixed(1)} ${unit})`;

        if (parseFloat(distanceInput.value) > maxDistanceInUnit) {
            distanceInput.value = maxDistanceInUnit;
            distanceSlider.value = maxDistanceInUnit;
        }
        updateDelay();
    }

    // === 5. イベントリスナーの設定 ===
    
    // 開始ボタン
    startButton.addEventListener('click', async () => {
        try {
            if (audioContext.state === 'suspended') {
                await audioContext.resume();
            }
            delayNode.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            await startCamera();
            
            statusElement.textContent = "シミュレーション中です。";
            startButton.style.display = 'none';
            controlsElement.style.display = 'block';
            updateDistanceControls();
        } catch (error) {
            console.error("開始処理中にエラーが発生しました:", error);
            statusElement.innerHTML = "<p>エラーが発生しました。ページを再読み込みしてください。</p>";
        }
    });

    // カメラ切り替えボタン
    cameraSwitchButton.addEventListener('click', () => {
        if (videoDevices.length > 1) {
            currentDeviceIndex = (currentDeviceIndex + 1) % videoDevices.length;
            const nextDeviceId = videoDevices[currentDeviceIndex].deviceId;
            startCamera(nextDeviceId);
        }
    });

    // カメラON/OFFボタン
    cameraToggleButton.addEventListener('click', toggleCamera);

    // 音量スライダー
    volumeSlider.addEventListener('input', () => {
        gainNode.gain.value = volumeSlider.value;
    });

    // 音速セレクター
    speedSelector.addEventListener('change', updateDistanceControls);

    // 距離入力（数値）
    distanceInput.addEventListener('input', () => {
        resetAudioBuffer();
        const value = parseFloat(distanceInput.value) || 0;
        const max = parseFloat(distanceInput.max);
        if (value > max) {
            distanceInput.value = max;
        }
        distanceSlider.value = distanceInput.value;
        updateDelay();
    });

    // 単位セレクター
    unitSelector.addEventListener('change', () => {
        resetAudioBuffer();
        updateDistanceControls();
    });

    // 距離スライダー
    distanceSlider.addEventListener('input', () => {
        resetAudioBuffer();
        distanceInput.value = distanceSlider.value;
        updateDelay();
    });

    // 遅延表示トグル
    toggleDelay.addEventListener('change', () => {
        delayDisplayContainer.style.display = toggleDelay.checked ? 'block' : 'none';
    });

</script>

</body>
</html>
